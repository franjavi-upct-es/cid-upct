---
title: "Análisis y Diseño de Algoritmos"
subtitle: "Sistema de Asignación de Mecánicos y Averías"
author: 
- "Francisco Javier Mercader Martínez"
- "Pedro Alarcón Fuentes"
output:
  pdf_document:
    latex_engine: pdflatex
geometry: margin=1.5cm
fontsize: 12pt
---

```{r include=FALSE}
setwd("C:/Users/fcoja/iCloudDrive/cid-upct/Prácticas/2º Curso/1º Cuatrimestre/ADA/ADA_boletin_P1/enunciados/01 - mecánicos y averías")

Sys.setenv(RETICULATE_PYTHON = "C:/Users/fcoja/.conda/envs/optim-2/python.exe")
library(reticulate)
py_config()
```

```{python, include=FALSE}
import os
import matplotlib.pyplot as plt
import time
import textwrap
```

En esta memoria se explicará el código utilizado para crear una sistema para la asignación de mecánicos a diferentes averías, evaluando las capacidades de los mecánicos para reparar averías específicas y optimizando el proceso de asignación. La estructura permite procesar varios casos de prueba y validar los resultados de cada asignación.

**Índice de Funciones**

1.  **`encontrar_archivos_in`**
2.  **`leer_entrada`**
3.  **`factible`**
4.  **`select`**
5.  **`solution`**

------------------------------------------------------------------------

## 1. Función **`encontrar_archivos_in`**

```{python}
def encontrar_archivos_in(directorio='.'):
    """
    Busca todos los archivos .in en el directorio especificado.

    :param directorio: Ruta del directorio donde buscar archivos `.in`.
    :return: Lista de rutas de archivos `.in` encontradas.
    """
    archivos_in = []
    for root, _, files in os.walk(directorio):
        for file in files:
            if file.endswith('.in'):
                archivos_in.append(os.path.join(root, file))
    return archivos_in
```

**Descripción:** Busca y devuelve una lista de archivos con extensión **`.in`** en el directorio especificado, que se utilizarán como entradas de datos para el programa.

------------------------------------------------------------------------

## 2. Función **`leer_entrada`**

```{python}
def leer_entrada(file_path):
    """
    Lee el archivo de entrada y convierte la información en una estructura de 
    datos adecuada.

    :param file_path: Ruta del archivo de entrada.
    :return: Número de casos de prueba (P) y lista de casos de prueba.
    """
    with open(file_path, 'r') as file:
        lineas = file.readlines()

    P = int(lineas[0].strip())
    casos = []
    indice = 1

    for _ in range(P):
        M, A = map(int, lineas[indice].strip().split())
        indice += 1

        capacidades = []
        for _ in range(M):
            capacidades.append(list(map(int, lineas[indice].strip().split())))
            indice += 1

        casos.append({'M': M, 'A': A, 'capacidades': capacidades})

    return P, casos
```

**Descripción y objetivo de la función:** La función **`leer_entrada`** se encarga de leer un archivo de entrada **`.in`** y extraer los datos necesarios para cada caso de prueba. Almacena el número de mecánicos y averías, así como las capacidades de cada mecánico para reparar averías específicas en una estructura de datos organizada.

## **Parámetros:**

-   **`file_path`** : La ruta al archivo de entrada

**Proceso:**

1.  Lee todas las líneas del archivo de entrada y extrae el número de casos de prueba.
2.  Para cada caso, lee el número de mecánicos (**`M`**) y averías (**`A`**).
3.  Crea una matriz **`capacidades`** que indica las habilidades de cada mecánico para reparar las averías.
4.  Almacena cada caso en una lista de diccionarios.

------------------------------------------------------------------------

## 3. Función **`factible`**

```{python}
def factible(mecanico, averia, capacidades, asignaciones):
    """
    Verifica si un mecánico puede ser asignado a una avería.

    :param mecanico: Índice del mecánico.
    :param averia: Índice de la avería.
    :param capacidades: Matriz de capacidades de los mecánicos.
    :param asignaciones: Lista de asignaciones de averías.
    :return: True si el mecánico puede reparar la avería y aún no ha sido asignada.
    """
    return capacidades[mecanico][averia] == 1 and asignaciones[averia] == 0
```

**Descripción:** Verifica si un mecánico específico puede ser asignado a una avería dada. Esto depende de la capacidad del mecánico para repararla y de si la avería ha sido asignada.

**Parámetros:**

-   **`mecanico`**: Índice del mecánico.

-   **`averia`**: Índice de la avería.

-   **`capacidades`**: Matriz que representa las capacidades de los mecánicos.

-   **`asignaciones`**: Lista de asignaciones para controlar qué averías han sido ya asignadas.

------------------------------------------------------------------------

## 4. Función **`select`**

```{python}
def select(mecanico, capacidades, asignaciones, A):
    """
    Selecciona la mejor avería que un mecánico puede reparar, si es posible.

    :param mecanico: Índice del mecánico.
    :param capacidades: Matriz de capacidades de los mecánicos.
    :param asignaciones: Lista de asignaciones de averías.
    :param A: Número de averías.
    :return: Índice de la avería seleccionada o -1 si no hay ninguna disponible.
    """
    for averia in range(A):
        if factible(mecanico, averia, capacidades, asignaciones):
            return averia
    return -1
```

**Descripción:** Esta función busca una avería que el mecánico puede reparar. Si encuentra una, devuelve el índice de la avería; si no, devuelve **`-1`**.

**Proceso:**

1.  Recorre cada avería posible.
2.  Usa la función **`factible`** para verificar si el mecánico puede asignarse a ella.
3.  Devuelve el índice de la primera avería factible.

------------------------------------------------------------------------

## 5. Función `solution`

```{python}
def solution(P, casos):
    """
    Resuelve el problema de asignación para cada caso de prueba.

    :param P: Número de casos de prueba.
    :param casos: Lista de casos de prueba.
    :return: Lista con las soluciones de cada caso.
    """
    resultados = []

    for caso in casos:
        M, A, capacidades = caso['M'], caso['A'], caso['capacidades']
        asignaciones = [0] * A  # Inicializa las asignaciones
        averias_reparadas = 0

        for mecanico in range(M):
            averia_seleccionada = select(mecanico, capacidades, asignaciones, A)
            if averia_seleccionada != -1:
                asignaciones[averia_seleccionada] = mecanico + 1  # Asigna el mecánico
                averias_reparadas += 1

        resultados.append((averias_reparadas, asignaciones))

    return resultados
```

**Descripción y objetivo de la función: `solution`** implementa el proceso de asignación para cada caso de prueba. Para cada mecánico, selecciona una avería que pueda reparar, y si la encuentra, se asigna y actualiza el número total de averías reparadas.

**Proceso:**

1.  Para cada caso, inicializa **`asignaciones`** con **`0`** para indicar avería ha sido asignada.
2.  Para cada mecánico, selecciona la avería adecuada mediante la función **`select`**.
3.  Lleva un conteo de averías asignadas y almacena el resultado de cada caso en una lista.

------------------------------------------------------------------------

## Resultado

```{python}
if __name__ == '__main__':
    file_paths = encontrar_archivos_in('.')

    for file_path in file_paths:
        P, casos = leer_entrada(file_path)
        resultados = solution(P, casos)

        print(P)
        for resultado in resultados:
            print(resultado[0])
            print(textwrap.fill(' '.join(map(str, resultado[1])), width=86))
        print()

```

```{python}
def analyze_complexity(file_paths):
    """
    Mide el tiempo de ejecución para cada archivo y genera un gráfico comparativo.

    :param file_paths: Lista de rutas de archivos `.in`.
    """
    sizes = []
    times = []

    for file_path in file_paths:
        # Medir el tiempo de ejecución para leer y procesar cada archivo
        start_time = time.time()

        # Leer la entrada y procesar los casos de prueba
        P, casos = leer_entrada(file_path)
        resultados = solution(P, casos)

        end_time = time.time()
        elapsed_time = end_time - start_time

        # Calcular el tamaño aproximado de la entrada
        with open(file_path, 'r') as f:
            size = sum(1 for _ in f)

        # Agregar el tamaño y tiempo a las listas
        sizes.append(size)
        times.append(elapsed_time)

    # Graficar el resultado comparativo para todos los archivos
    plt.plot(sizes, times, marker='o', linestyle='--')
    plt.xlabel('Tamaño aproximado')
    plt.ylabel('Tiempo (s)')
    plt.show()
```

Esta función mide el tiempo de ejecución para cada archivo en **`file_paths`** y crea un gráfico comparativo de los tiempos frente a los tamaños de entrada.

-   **Parámetros:**

    -   **`file_paths`**: lista de rutas de archivos **`.in`** que se analizarán.

-   **Proceso Interno:**

    1.  Incializa las listas **`sizes`** y **`times`** para almacenar los tamaños de entrada y los tiempos de ejecución.
    2.  Para cada archivo en **`file_paths`**:
        -   Mide el tiempo antes de la ejecución (**`start_time`**).

        -   Ejecuta **`leer_entrada`** para leer el archivo y **`solution`** para resolver los casos de prueba.

        -   Mide el tiempo después de la ejecución (**`end_time`**).

        -   Calcula el tiempo transcurrido (**`elapsed_time`**).

        -   Determina el tamaño del archivo en líneas (esto representa el tamaño de la entrada) y a los añade a **`sizes`**.

        -   Añade el tiempo transcurrido a **`times`**.
    3.  Genera una gráfica de líneas usando **`matplotlib`**, donde el eje $x$ representa el tamaño de entrada y el eje $y$ el tiempo de ejecución.

```{python}
analyze_complexity(file_paths)
```

### Observaciones del Gráfico

1.  **Relación Lineal**:
    -   La línea formada por los puntos muestra un crecimiento lineal en el tiempo de ejecución a medida que aumenta el tamaño del archivo de entrada. Esto indica que el tiempo de procesamiento aumenta de manera proporcional con el tamaño de los datos de entrada.
2.  **Escala de Tiempo**:
    -   El tiempo de ejecución es bajo (en el rango de milisegundos), lo cual es adecuado para los tamaños de entrada analizados. Sin embargo, esto puede cambiar si el tamaño de entrada crece significativamente, dado que la pendiente sugiere un incremento constante.
3.  **Pendiente Constante**:
    -   La pendiente de la línea es consistente, lo que sugiere que la complejidad del programa es lineal respecto al tamaño de los datos de entrada. En este contexto, el programa probablemente tiene una complejidad $O(N)$ para estos tamaños de entrada.

### Conclusiones

1.  **Eficiencia del Programa**:
    -   Para los tamaños de entrada utilizados, el programa demuestra una eficiencia aceptable y un tiempo de respuesta rápido. Esto es positivo, especialmente si el objetivo es procesar archivos de entrada de tamaño similar.
2.  **Escalabilidad**:
    -   Aunque el tiempo de ejecución es bajo para los tamaños probados, si el tamaño de entrada continúa creciendo, el tiempo de ejecución también aumentará linealmente. Esto indica que el programa debería manejar bien entradas moderadamente grandes, pero puede volverse más lento en el caso de archivos extremadamente grandes.


En general, el gráfico sugiere que el programa tiene un comportamiento predecible y escalable en un contexto de tamaño de entrada moderado, y su eficiencia es adecuada para los tamaños de datos probados.
