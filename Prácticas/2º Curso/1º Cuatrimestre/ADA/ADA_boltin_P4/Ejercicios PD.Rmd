---
title: "Análisis y Diseño de Algoritmos"
subtitle: "Tema 4: Programación dinámica"
author: "Francisco Javier Mercader Martínez"
output:
  pdf_document:
    latex_engine: pdflatex
geometry: margin=1.5cm, a4paper
fontsize: 11pt
header-includes:
- \renewcommand{\and}{\\}
- \usepackage{fvextra}
- \usepackage{hyperref}
- \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines, commandchars=\\\{\}}
- \usepackage{setspace}
- \setstretch{1.35}
---

```{r include = FALSE}
library(reticulate)
use_condaenv("optim-2", conda="C:/ProgramData/anaconda3/Scripts/conda.exe", required = TRUE)
py_config()
```

1.  En el problema de la mochila (igual que en el problema de cambio de monedas) puede existir en general más de una solución óptima para unas entradas determinadas. ¿Cómo se puede comprobar si una solución óptima es única o no, suponiendo que hemos resuelto el problema utilizando programación dinámica? Dar un algoritmo para que, a partir de las tablas resultantes del problema, muestre todas las soluciones óptimas existentes.

2.  El número de combinaciones de **`m`** objetos entre un conjunto de **`n`**, denotado por $\dbinom{n}{m}$, para $n\ge1$ y $0\le m\le n$, se puede definir recursivamente por:

    -   $\dbinom{n}{m}=1\quad$ Si $m=0$ ó $m=n$.

    -   $\dbinom{n}{m}=\dbinom{n-1}{m}+\dbinom{n-1}{m-1}\quad$ Si $0<m<n$.

    -   Conociendo que el resultado puede ser calculado también con la siguiente fórmula: $\dfrac{n!}{m!(n-m)!}$

        a.  Dar una función recursiva para calcular $\dbinom{n}{m}$, usando la primera de las definiciones. ¿Cuál será el orden de complejidad de este algoritmo? Sugerencia: la respuesta es inmediata.
        b.  Diseñar un algoritmo de programación dinámica para calcular $\dbinom{n}{m}$. Nota: la tabla construida por el algoritmo es conocida como *"el triángulo de Pascal"*. ¿Cuál será el tiempo de ejecución en este caso?

3.  Considerar el problema de la mochila 0/1. En este ejercicio estamos interesado en calcular el número de formas distintas de meter o no los objetos en la mochila, pero respetando la capacidad máxima de la mochila. Por ejemplo, si todos los **`n`** objetos cupieran en la mochila, existirán $\mathbf{2^n}$ formas posibles. Pero en general, si no caben todos, habrán muchas menos. Resolver mediante programación dinámica el problema de calcular el número de formas distintas de completar total o parcialmente la mochila. Datos del problema: **`n`** objetos, `M` capacidad de la mochila, $\mathbf{\mathtt{p=(p_1,p_2,\dots,p_n)}}$ pesos de los objetos).

    |       |  0  |  1  |  2  |  3  |  4  |  5  |  6  |
    |:-----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
    | **0** |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
    | **1** |  1  |  1  |  2  |  2  |  2  |  2  |  2  |
    | **2** |  1  |  1  |  2  |  3  |  3  |  4  |  4  |
    | **3** |  1  |  1  |  2  |  3  |  4  |  5  |  6  |

    $\begin{array}{l}m=3,\quad M=6\\ p=(2,3,4)\\ k=0\text{ y }M=0\longrightarrow \begin{cases}\text{No }\to\max f(k-1,\,m)\\ +\\ \text{Si }\to\max f(k-1,\,m-p_k)\end{cases}\end{array}$

4.  Una variante del problema de la mochila es la siguiente. Tenemos un conjunto de enteros (positivos) $\mathbf{\mathtt{A=\{a_1, a_2,\dots,a_n\}}}$ y un entero $K$. El objetivo es encontrar
