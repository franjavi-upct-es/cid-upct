% !TeX spellcheck = es_ES
\section{Bases de datos basadas en documentos}
\subsection{Introducción a las bases de datos de documentos}
\subsubsection{Bases datos Documentales}
En general, organizadas como un conjunto de \textbf{Colecciones} que contienen \textbf{documentos}:
\begin{itemize}
\item Tablas relacionales $\leftrightarrow$ Colecciones
\item Filas (\textit{rows}) $\leftrightarrow$ Documentos
\item No restringen la estructura de cada documento y no tienen esquema
\end{itemize}
Cada colección es un \textit{array} donde cada documento tiene asociado un identificador

La base de datos puede ver el contenido del documento, y utilizar su información como parte de las búsquedas y actualizaciones

Documentos $\Rightarrow$ formatos jerárquicos tipo JSON o XML

No utilizan SQL y tienen su lenguaje de consulta propio

Utilizan normalmente \textbf{Map-Reduce} para cálculos distribuidos

Algunas implementan otros lenguajes de consulta y procesado, como N1QL (Couchbase) y Aggregation Framework (MongoDB)

Bases de datos de Documentos: Couchbase, MongoDB, OrientDB
\subsection{Modelado de bases de datos de documentos}
\subsubsection{Modelado de datos en NoSQL}
El modelado de datos debe ser:
\begin{itemize}
\item Realizado al mayor nivel de abstracción posible
\item Independiente de la tecnología subyacente
\end{itemize}
Sin embargo, en NoSQL:
\begin{itemize}
\item  Se tiene que tener en cuenta el diseño \textbf{distribuido}
\item \textbf{Optimización guiada por las consultas}
\end{itemize}
Con respecto al modelo de datos:
\begin{itemize}
\item Se mantienen los conceptos de entidad, relación, cardinalidades, etc.
\item El modelado relacional se centra en especificar \textbf{qué datos tenemos y podemos ofrecer}
\item El modelo NoSQL se centra en \textbf{optimizar qué consultas vamos a servir}
\item Es "barato" \textbf{duplicar (desnormalizar)} los datos si con ello se consigue \textbf{mayor eficiencia de acceso}
\end{itemize}
\subsubsection{Representación de CV como tablas}
\begin{center}
	\includegraphics[scale=0.8]{"Temas/Tema 3/screenshot001"}
\end{center}
\subsubsection{Representación de relaciones}
\subsubsubsection{Relaciones uno a muchos}
Las relaciones uno a muchos (por ejemplo en el CV: \texttt{positions}) en el modelo relacional:
\begin{itemize}
	\item Normalización usando varias tablas (\texttt{Positions} con \texttt{user_id})
\begin{itemize}
	\item Necesidad de más de una tabla
\item Necesidad de uso de \texttt{JOIN} $\Rightarrow$ ineficiencia
\end{itemize}
\item Algunos SGBDR ofrecen la posibilidad de tener tipos de datos estructurados y campos XML o JSON. (P. ej. PostgreSQL)
\begin{itemize}
	\item Usualmente no se pueden usar para buscar dentro
\item No son estándar
\end{itemize}
\end{itemize}
\subsubsection{CV como un documento}
\begin{lstlisting}[language=json]
{
	"user_id": 251,	"first_name": "Bill",
	"last_name": "Gates",
	"summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
	"region_id": "us:91",
	"industry_id": 131,
	"photo_url": "p/7/000/253/05b/308dd6e.jpg",
	"positions": [
	{
		"job_title": "Co-chair",
		"organization": "Bill & Melinda Gates Foundation"
	},
	{
		"job_title": "Co-founder Chairman",
		"organization": "Microsoft"
	}],
	"education": [
	{
		"school_name": "Harvard University",
		"start": 1973,
		"end": 1975
	},
	{
		"school_name": "Lakeside School, Seattle",
		"start": null,
		"end": null
	}]
	"contact_info": {
		"blog": "http://theganotes.com"
		"twitter": "http://twitter.com/BillGates"
	}
}
\end{lstlisting}
\subsubsection{CV como un árbol}
\begin{center}
	\includegraphics{"Temas/Tema 3/screenshot002"}
\end{center}
\subsubsection{Representación de Relaciones}
\subsubsubsection{Modelo de documentos}
\textbf{Modelo de documentos}
\begin{itemize}
	\item analogía del \textbf{array/mapa gigante}
\end{itemize}
\textbf{Conjunto de documentos} (objetos complejos)
\begin{itemize}
	\item Un \textbf{identificador único}, campo \textit{id}
	\item Búsqueda aleatoria eficiente por clave (\textbf{referencia})
	\item Estructura jerárquica de sub-documentos contenidos $\longrightarrow$ \textbf{agregación}
\end{itemize}
\textbf{Más flexibilidad que el modelo relacional:} (elección entre \underline{\textit{referencia}} Y \underline{\textit{agregación}})
\subsubsubsection{Uno a muchos - NoSQL}
Relaciones \textbf{Uno a Muchos} (\texttt{postions}):
\begin{itemize}
	\item \textbf{Opción 1:} Agregando la tabla \texttt{positions}
	\item \textbf{Opción 2:} Convertir las empresas en entidades, y utilizar una \textbf{\textit{referencia}}.
\end{itemize}
\textbf{Modelado guiado por el acceso a datos:}
\begin{itemize}
	\item Si los elementos "muchos" tienen una estructura sencilla $\Longrightarrow$ \textbf{Opción 1}.
	\item Si los elementos "muchos" son usualmente \textbf{recuperados en una consulta} junto con el elemento "uno" $\Longrightarrow$ \textbf{Opción 1}.
	\item Si lo elementos "muchos" son relativamente grandes, o bien son recuperados siempre de forma separada $\Longrightarrow$ \textbf{Opción 2}.
\end{itemize}
\subsubsubsection{Muchos a uno y muchos a muchos}
Las relaciones muchos a uno y muchos a muchos:
\begin{itemize}
	\item Personas que viven en una región.
	\item Preguntas que refieren a Tags.
\end{itemize}
El modelo de documentos no aporta ventajas con respecto al modelo relacional.\\
Al haber muchas entidades que refieren a otra entidad, la \textit{agregación} daría lugar a mucha \textbf{duplicación} (y a problemas de sincronización).\\
\textbf{Referencias} (sobre el ID), similar a una FK en el modelo relacional.
\begin{itemize}
	\item \textbf{Sin embargo}, al no haber \textbf{JOINs} la aplicación tiene que hacer más de una petición a la BD.
\end{itemize}
\begin{center}
	\includegraphics{"Temas/Tema 3/screenshot003"}
\end{center}
\subsection{Introducción a MongoDB}
Base de datos documental

Basado en una representación binaria de JSON, llamada BSON

Cada base de datos se divide en un conjunto de \textit{colecciones}

Una colección es un conjunto arbitrariamente grande de documentos

Cada documento contiene un campo especial \texttt{_id}, que guarda un objeto de tipo especial \texttt{ObjectID} de BSON

Permite la definición de bases de datos, colecciones (tablas \textit{hash} de documentos) y subcolecciones

Permite realizar búsquedas secuenciales, programas MapReduce y un API propietario de consulta (llamado \textit{aggregate})

Ofrece un \textit{shell} que acepta JavaScript y permite realizar operaciones directamente sobre la base de datos

También ofrece clientes en muchos lenguajes de programación
\subsubsection{Uso básico de MongoDB}
MongoDB ofrece un \textit{shell}, aparte de las posibles conexiones remotas a través de \textit{drivers} usando otros lenguajes de programación.\\
El shell acepta código JavaScript\\
Veremos inicialmente su uso\\
Existen una serie de objetos predefinidos\\
\begin{lstlisting}[language=JavaScript]
show databases;
use <database>;
db.<collection>;  // Permite acceder a la colección
\end{lstlisting}

Simplemente nombrando las colecciones se puede acceder a ellas para consulta y actualización.\\
Inserción de documentos:
\begin{lstlisting}[language=JavaScript]
db.colección.insert({< Objeto JSON >});
\end{lstlisting}
\subsubsection{Actualización y consulta}
Se puede obtener los documentos de la base de datos con:
\begin{lstlisting}[language=JavaScript]
var objeto = db.colección.findOne({atributos : valores})
// ó encontrar todos lo que cumplen la condición:
var objs = db.colección.find({ atributos : valores })
\end{lstlisting}
Y actualizarlos:
\begin{lstlisting}[language=JavaScript]
db.colección.update(
	{ atributos: valores}, 	// búsqueda
	objeto);								// nuevo objeto
\end{lstlisting}
La selección del objeto se suele hacer por su \texttt{_id}, que es único.

También permite modificadores:

\begin{lstlisting}[language=JavaScript]
	db.analytics.update({"url" : "www.example.com"},
	{"$inc" : {"pageviews" : 1}})
\end{lstlisting}

También \texttt{\$set}, \texttt{\$unset}, \texttt{\$push} (para \textit{arrays}), \texttt{\$pull} (para eliminar elementos de una \textit{array} que cumplen un criterio).
\subsubsection{Consultas MapReduce}
Las consultas se hacen con \texttt{find}:
\begin{lstlisting}[language=JavaScript]
d.users.find({<criterio>},
						 {"username" : 1, "_id" : 0})
// =>
{
"username" : "joe",
}
\end{lstlisting}
Y se pueden utilizar condicionantes para la búsqueda:
\begin{lstlisting}[language = JavaScript]
db.user.find({"age": {"$gte": 18, "$lte": 30}});
db.user.find({"$or": [{"age": {"$gte": 18} },
											{"permission": true} ] });
\end{lstlisting}

\textit{Map-reduce} es un paradigma de procesamiento de datos que permite condensar grandes volúmenes de datos en resultados agregados útiles.

Una operación map-reduce consta de tres fases:
\begin{enumerate}[label=\arabic*)]
	\item Se aplica la función \texttt{Map (Map(k1, v1) $\rightarrow$ list(k2, v2)} a cada documento de entrada. La función Map se aplica en paralelo a cada documento (con clave \texttt{k1}) del conjunto de datos de entrada. Esto produce una lista de pares (codificados por \texttt{k2}) para cada llamada.
	\item La función \texttt{Reduce (Reduce(k2, list (v2)) $\rightarrow$ list((k3, v3)))} se aplica entonces en paralelo a cada grupo.
\end{enumerate}
\subsubsection{Validación del esquema}
En sus últimas versiones MongoDB ha incorporado funcionalidades que permiten anotar y validar documentos JSON (\textit{JSON Schema}).

A la hora de crear una colección, podemos especificar en \textit{JSON schema} qué configuración deben seguir los documentos almacenados en ella.

\Ej 

Vamos a crear una colección \texttt{estudiantes} y vamos a especificar su esquema asociado

\begin{lstlisting}[language=JavaScript]
	db.createColecction("estudiantes",{
		validator: {
			$jsonSchema: {
				bsonType: "object",
				title: "Validación del objeto Estudiante",
				required: [ "dirección", "major", "nombre", "año"],
				properties: {
					nombre: {
						bsonType: "string",
						description: "'nombre' debe ser una cadena (string) y es obligatorio"
					},
					año: {
						bsonType: "int",
						minimum: 2017,
						maximum: 3017,
						description: "'año' debe ser un entero entre [ 2017, 3017 ] y es obligatorio"
					},
					gpa: {
						bsonType: [ "double" ],
						description: "'gpa' debe ser un double si el campo existe"
					}
				}
			}
		}
	} )
\end{lstlisting}

Si ahora intentamos insertar un documento que no cumple dicho esquema 
\begin{lstlisting}[language=JavaScript]
db.estudiantes.insertOne( {
	nombre: "Alice",
	year: Int32( 2019 ),
	major: "Historia",
	gpa: Int32(3),
	direccion: {
		city: "USA",
		street: "Fraggel Rock"
	}
} ) 
\end{lstlisting}
obtendremos un mensaje de error pues el campo \texttt{gpa} se ha insertado como \texttt{Int} cuando debía hacerse como \texttt{double}.
\begin{lstlisting}[language=JavaScript]
	MongoServerError: Document failed validation
	Additional information: {
		failingDocumentId: ObjectId("630d093a931191850b40d0a9"),
		details: {
			title: 'Validacion del objeto Estudiante',
			operatorName: '$jsonSchema',
			schemaRulesNotSatisfied: [
			{
				operatorName: 'properties',
				propertiesNotSatisfied: [
				{
					propertyName: 'gpa',
					description: "'gpa' debe de ser un doble si el campo existe",
					details: [
					{
						operatorName: 'bsonType',
						specifiedAs: { bsonType: [ 'double' ] },
						reason: 'type did not match',
						consideredValue: 3,
						consideredType: 'int'
					}
					] } ] } ]} }
\end{lstlisting}

Sin embargo, la siguiente inserción no provoca ningún fallo
\begin{lstlisting}[language=JavaScript]
db.students.insertOne( {
	name: "Alice",
	year: NumberInt(2019),
	major: "History",
	gpa: Double(3.0),
	address: {
		city: "NYC",
		street: "33rd Street"
	}
})
\end{lstlisting}
\subsubsection{Índices y desnormalización}
\subsubsubsection{Índices}
Sea con SQL o con datos \textit{raw}, la búsqueda no se puede realizar secuencialmente

Los \textbf{\textit{índices}} se utilizan para acelerar esta búsqueda

El concepto de índice está presente en casi todas las bases de datos (también es un eje principal en las NoSQL)

En el ámbito del SQL, los índices se pueden aplicar a los valores de una o más columnas

Se usan para acelerar la recuperación de información

El planificador de consultas usa los índices disponibles

Es \textbf{labor del usuario} definir los índices adecuados

Los índices aceleran las búsquedas, pero también ocupan espacio

En SQL se utiliza la construcción \texttt{CREATE INDEX, ALTER TABLE} o se incluyen en \texttt{CREATE TABLE}

\texttt{EXPLAIN} para ver si se usa:

\begin{lstlisting}[language=sql]
mysql> explain select * from Posts where Id=5;
+----+-------------+-------+------+---------------+-----+...
| id | select_type | table | type | possible_keys | key |...
+----+-------------+-------+------+---------------+-----+...
|  1 | SIMPLE      | Posts | ref  | Id            | Id  |...
+----+-------------+-------+------+---------------+-----+...
\end{lstlisting}
Obviamente \textbf{también} se usan las base de datos NoSQL.

En general, hay tres tipos de índices:
\begin{enumerate}[label=\arabic*)]
	\item Basados en árboles balanceados
	\item Basado en tablas \textit{hash}
	\item Índices \textit{full-text}
\end{enumerate}
\begin{itemize}[label=\color{red}\textbullet, leftmargin=*]
	\item \lb{Índices de Árboles Balanceados}
	\begin{itemize}
		\item Mantienen la clave ordenada dentro de un árbol balanceado (B-Tree, B+, ect)
		\item Aceleran búsquedas con operadores =, < y > y rangos (\texttt{BETWEEN})
		\item También \texttt{LIKE} que no empiecen con comodín
		\item Puede ayudar en \texttt{ORDER BY}
	\end{itemize}
	\item \lb{Índices de tablas \textit{hash}}
	\begin{itemize}
		\item Sólo para consultas de igualdad (=) y desigualdad (<=>)
		\item Son muy rápidos
		\item No se pueden usar para \texttt{ORDER BY}
		\item Sólo se pueden usar con valores completos de clave (no permite prefijos, por ejemplo)
	\end{itemize}
	\item \lb{Índices \textit{full-text}}
	\begin{itemize}
		\item Usados en búsquedas inversas sobre campos textuales.
		\item Dada una palabra o conjunto de palabras, encontrar la fila o filas en las que el campo buscado (el del índice) contiene esas palabras
		\item Tiene limitaciones en \texttt{LIKE} con comodines (\%).
		\item Por ello los SGBD proveen operadores especiales (por ejemplo, en MySQL \code{"MATCH(...) AGAINST ..."})
	\end{itemize}
\end{itemize}
\subsubsubsection{Desnormalización}
El modelo relacional basa el modelado de datos en la \textbf{normalización}, en sus distintos niveles

Esto permite aplicar el principio de "sólo almacenar un dato en un sitio", lo que lleva a la eficiencia de datos.

Pero a veces necesitamos también \textbf{eficiencia de acceso}, y a veces está reñido con la normalización.

El principal escollo para la velocidad es la unión (\texttt{JOIN}) de datos de tablas.

¿Por qué desnormalizar?
\begin{itemize}
	\item \textbf{Matener la historia:} Los datos de los clientes, por ejemplo, pueden cambiar. Necesitamos almacenar los valores de los mismos, por ejemplo, cuando emitimos una factura en el pasado. Para eso hay que copiar los datos de un cliente en ese momento.
	\item \textbf{Mejorar la velocidad de consulta:} A veces, para hacer consultas recurrentes, tenemos que usar uniones de varias tablas. Evitar la unión, por ejemplo, añadiendo claves ajenas a las tablas finales. O bien, como en el caso de \code{Posts.Tags}, replicando la información.
	\item \textbf{Precalcular valores necesitados de antemano:} Si hay datos que se necesitarán, como medias o totales, podemos calcularlos y almacenarlos de antemano.
\end{itemize}
Desventajas de desnormalizar:
\begin{itemize}
	\item \textbf{Espacio en disco:} Al igual que ocurría con los índices, la copia y duplicación de datos ocupa más espacio
	\item \textbf{Anomalías de datos:} Hay que ser conscientes de que ahora un cambio en un dato puede requerir un cambio en más de una parte de la base de datos para mantener la consistencia. Los SGBDR no están preparados para mantener este tipo de consistencia. Se tienen que utilizar mecanismos de \textit{triggers}, transacciones, etc.
	\item \textbf{Ralentización de las operaciones de actualización:} Dependiendo del \textit{ratio} entre actualizaciones y consultas, este puede ser un punto importante
	\item \textbf{Más código, más dependencias, más propenso a errores:} Al necesitar más coordinación, la base de datos requiere más código, hay más dependencias ocultas, lo que puede llevar a más errores y a un mayor coste de mantenimiento.
\end{itemize}
\subsection{Uso de MongoDB desde \code{pymongo}}
\subsubsection{Métodos de búsqueda}
El método de búsqueda principal es \code{find()}, que tiene muchas opciones

En general permite especificar:
\begin{itemize}
	\item El filtro de búsqueda
	\item Ordenación de resultados por algún campo
	\item Proyección para no obtener todos los campos del documento
	\item Número de resultados máximo (\textit{limit})
	\item Número de elementos iniciales a ignorar (\textit{skip})
	\item El tamaño del \textit{batch}
\end{itemize}
Como la variabilidad es muy grande, veremos ejemplos en la hoja Jupyter Notebook de prácticas y también en la documentación

La función \code{find()} tiene un gran número de posibilidades para especificar la búsqueda. Se pueden utilizar cualificadores complejos como:
\begin{itemize}
	\item \code{\$and}
	\item \code{\$or}
	\item \code{\$not}
\end{itemize}
Estos calificadores unen "objetos", no valores.

Por otro lado, hay otros calificadores que se refieren a valores:
\begin{itemize}
	\item \code{\$lt} (menor)
	\item \code{\$lte} (menor o igual)
	\item \code{\$gt} (mayor)
	\item \code{\$gte} (mayor o igual)
	\item \code{\$regex} (expresión regular)
\end{itemize}
\begin{lstlisting}[language=python]
posts.find_one({"body": {"$regrex": "[Mm]ongo"}})
\end{lstlisting}
Condición compuesta (limitando la salida a 10 documentos):
\begin{lstlisting}[language=python]
posts.find({"$and": [{"PostTypeId": 2},
	{"Id" : {"$gte": 100}} ]})
		.limit(10)
\end{lstlisting}
\subsubsubsection{Ejemplos introductorios}
\begin{itemize}[leftmargin=*]
	\item Encontrar el primer documento en la colección \texttt{customers}
	\begin{lstlisting}[language=python]
myclient = pymongo.MongoClient("mongodb://localhost:27017/")
mydb = myclient["mydatabase"]
mycol = myclient["customers"]
x = mycol.find_one()
	\end{lstlisting}
	\item Encontrar el campo de todos los documentos en la colección \texttt{customers}
\begin{lstlisting}[language=python]
for x in mycol.find():
	print(x)
\end{lstlisting}
También podemos indicar qué campos queremos obtener determinada búsqueda
\begin{lstlisting}[language=python]
for x in mycol.find({}, {"_id": 0, "name": 1, "address": 1}):
	print(x)
\end{lstlisting}
\end{itemize}
\subsubsubsection{Ejemplos básicos}
\begin{itemize}
	\item Dada la siguiente colección
\begin{lstlisting}[language=python]
{ "_id": "manzanas", "cantidad": 5 }
{ "_id": "plátanos", "cantidad": 7 }
{ "_id": "naranjas", "cantidad": 8 }
{ "_id": "aguacate", "cantidad": 14 }
\end{lstlisting}
\item Si quisieramos obtener aquellos documentos con un valor en su atributo \texttt{cantidad} superior a 4 deberíamos ejecutar el siguiente comando
\begin{lstlisting}[language=python]
db.collection.find( { "cantidad": { "$gt": 4} } )
\end{lstlisting}
¿Qué comando deberíamos lanzar para obtener aquellos que tengan un valor inferior o igual a 5?
\begin{lstlisting}[language=python]
db.collection.find( { "cantidad": { "$lte": 5} } )
\end{lstlisting}
Suponiendo una colección \texttt{bios} cuyos documentos tienen esta forma:
\begin{lstlisting}[language=python]
{
	"_id": <valor>,
	"nombre" : { "nombre_propio" : <string>, "primer_apellido" : <string>},
	"nacimiento" : <ISODate>,
	"muerte" : <ISODate>,
	"profesión" : <valor>,
	"trabajos" : [<string>, ...] 
}
\end{lstlisting}
\item Una opción interesante es el filtrado por rango de fechas en caso de que tengamos atributos de ese tipo
\begin{lstlisting}[language=python]
db.bios.find( { "nacimiento": { "$gt": new Date('1940-01-01'), 
	"$lt": new Date('1960-01-01') } } )
\end{lstlisting}
\item El operador \code{\$in} nos permite buscar documentos con atributos dentro de una lista de valores.
\begin{lstlisting}[language=python]
db.bios.find(
	{ "profesion": { "$in": [ 'jedi', 'samurai' ] } }
)
\end{lstlisting}
\item Tabién podemos realizar búsquedas en campos anidados
\begin{lstlisting}[language=python]
db.bios.find( { "nombre.primer_apellido": "Skywalker" } )
db.bios.find(
	{ "nombre": { "nombre_propio": "Akira", "primer_apellido": "Kurosawa" } }
)
\end{lstlisting}
\item Las búsquedas pueden realizarse también sobre campos cuyos valores son arrays
\begin{lstlisting}[language=python]
db.bios.find({"trabajos": "star wars"})
db.bios.find({"trabajos": { "$in": ["star wars", "alien"]} })
db.bios.find({"trabajos": { "$all": [ "star wars", "the clone wars" ]}})
db.bios.find({"trabajos": { "$size": 4 }}) #El array 'trabajos' debe tener 4 elementos
\end{lstlisting}
\item El operador \code{\$not} es útl cuando queremos buscar elementos que \textbf{no} cumplan una condición
\begin{lstlisting}[language=python]
# Buscar documentos cuyo precio no sea superior a 1.99€ o que no tengan el campo "precio"
db.inventory.find( { "precio": { "$not": { "$gt": 1.99 } } } )
\end{lstlisting}
\item Por último, los operadores \code{\$and}, \code{\$or} y \code{\$not} pueden combinarse para definir condiciones complejas:
\begin{lstlisting}[language=python]
db.inventory.find( { 
	"$and": [
		{"$or": [{"cantidad"}:{"$lt":10}, {"cantidad":{"$gt": 50} }]},
		{"$or": [{"vendido": true}, {"precio": {"$lt": 5}}]}
	]
} )
\end{lstlisting}
\end{itemize}
\subsubsection{Métodos de inserción y actualización}
\texttt{pymongo} ofrece métodos para inserción y actualización:
\begin{itemize}
	\item \code{insert_one(), insert_many()} (batch)
	\item \code{update_one()}: Permite actualizar un objeto con nuevos campos. El objeto se crea si se pone el parámetro \code{upsert} a \code{True}
	\item \code{update_many()}: Permite obtener nuevos valores calculado a un conjunto de objetos.
\end{itemize}
A la hora de insertar un elemento poder obtener su \code{_id} asignado
\begin{lstlisting}[language=python]
micoleccion = db["clientes"]
midict = { "nombre": "Luke", "direccion": "Tatooine, 83" }
x = mycol.insert_one(midict)
print(x.inserted_id)
\end{lstlisting}
Para insertar un conjunto de documentos a la vez deberemos incluirlos en un array JSON
\begin{lstlisting}[language=python]
miLista = [
	{ "nombre": "Amy", "direccion": "Apple st 652"},
	{ "nombre": "Hannah", "direccion": "Mountain 21"},
	{ "nombre": "Michael", "direccion": "Valley 345"}
]
x = micoleccion.insert_many(miLista)
# Imprimimos sus _id asignados
print(x.inserted_ids)
\end{lstlisting}
A la hora de actualizar un documento debemos especificar un criterio de búsqueda y los campos y valores a actualizar.
\begin{lstlisting}[language=python]
micoleccion = db["clientes"]
mifiltro = { "direccion": "Valley " }
nuevosvalores = { "$set": { "direccion": "Rue del percebe, 13" } }
micoleccion.update_one(mifiltro, nuevosvalores)
\end{lstlisting}
Para actualizar múltiples documentos la estructura es la misma
\begin{lstlisting}[language=python]
micoleccion = db["clientes"]
mifiltro = { "direccion": { "$regrex": "^S" } }
nuevosvalores = { "$set": { "nombre": "Rey" } }
x = micoleccion.update_many(mifiltro, nuevosvalores)
print(x.modified_count, "documentos actualizados.")
\end{lstlisting}
\subsubsubsection{Índices, \code{explain()}}
La llamada \code{.explain()} a cualquier búsqueda muestra el plan de ejecución.

Se puede crear un índice si la búsqueda por ese campo va a ser crítica.

Se pueden crear más índices:
\begin{itemize}
	\item \code{ASCENDING}
	\item \code{DESCENDING}
	\item \code{HASHED}
	\item Geoespaciales
\end{itemize}
\subsubsection{Framework de agregación}
El framework de agregación de MongoDB es una de sus características más potentes

Permite escribir expresiones, divididas en una serie de etapas, que realizan operaciones como agregaciones, transformaciones y uniones en los datos de las bases de datos MongoDB

Esto le permite realizar cálculos y análisis a través de documentos y colecciones dentro de su base de datos MongoDB
\begin{center}
	\includegraphics{"Temas/Tema 3/screenshot004"}
\end{center}
Framework de agregación: \url{https://docs.mongodb.com/manual/reference/operator/aggregation/}
\begin{lstlisting}[language=python]
posts.aggregate ( [
	{"$project" : { "Id" : 1 }},
	{"$limit": 20}
])
\end{lstlisting}
\begin{lstlisting}[language=python]
by_length = posts.aggregate( [
	{'$project': {
		'Body': {'$ifNull' : ['$Body', '']}
	}},
	{'$project': {
		'id' : {'$strLenBytes': '$Body'},
		'value' : {'$literal' : 1}
	}},
	{'$group': {
		'_id' : '$id',
		'count' : {'$sum' : '$value'}
	}},
	{'$sort' : { '_id' : 1 }}
])
\end{lstlisting}
Se pueden añadir etapas. En particular, por ejemplo, se puede \textbf{filtrar} inicialmente añadiendo al principio:
\begin{lstlisting}[language=python]
{'$match':  { 'Body' : {'$regex': 'HBase'}}}
\end{lstlisting}
La construcción \code{\$lookup} permite el acceso a otra (o a la misma) colección. Es equivalente a un \textbf{JOIN}.

Por ejemplo, listar los posts con Score mayor o igual a 40 junto con el usuario que lo ha hecho:
\begin{lstlisting}[language=python]
posts.aggregate( [
	{'$match': { 'Score' : {'$gte': 40}}},
	{'$lookup': {
		'from': "users",
		'localField': "OwnerUserId",
		'foreingField': "Id",
		'as': "owner"}
	}
])
\end{lstlisting}
Vamos a suponer que contamos con una colección de películas (\texttt{movies}) que contienen documentos que tienen esta estructura:
\begin{lstlisting}[language=python]
{
	'_id': ObjectId('573a1392f29313caabcdb497'),
	'awards': {'nominations': 7,
				'text': 'Won 1 Oscar. Another 2 wins & 7 nominations.',
				'wins': 3},
	'cast': ['Janet Gaynor', 'Fredric March', 'Adolphe Menjou', 'May Robson'],
	'countries': ['USA'],
	'directors': ['Willianm A. Wellman', 'Jack Conway'],
	'fullplot': 'Esther Blodgett is just...',
	'genres': ['Drama'],
	'imdb': {'id': 29606, 'rating': 7.7, 'votes': 5005},
	'languages': ['English'],
	'lastupdated': '2015-09-01 00:55:54.333000000',
	'plot': 'A young woman ...',
	'poster': 'https://m.media-amazon.com/images/M/MV5....jpg',
	'rated': 'NOT RATED',
	'released': datetime.datetime(1937, 4, 27, 0, 0),
	'runtime': 111,
	'title': 'A Star Is Born',
	'tomatoes': {'critic': {'meter': 100, 'numReviews': 11, 'rating': 7.4},
				'dvd': datetime.datetime(2004, 11, 16, 0, 0),
				'fresh': 11,
				'lastUpdated': datetime.datetime(2015, 8, 26, 18, 58, 34),
				'production': 'Image Entertainment Inc. ',
				'rotten': 0,
				'viewer': {'meter': 79, 'numReviews': 2526, 'rating': 3.6},
				'website': 'http://www.vcientertainment.com/Film-Categories?product_id=73'},
	'type': 'movie',
	'writers': ['Dorothy Parker (screen play)',
				'Alan Campbell (screen play)',
				'Robert Carson (screen play)',
				'William A. Wellman (from a story by)',
				'Robert Carson (from a story by)'],
	'year': 1937}
\end{lstlisting}
\Ej

En primer lugar vamos a realizar una primera búsqueda sobre dicha colección filtrando por el nombre de la película (\texttt{title}) y ordenando por su año (\texttt{year}):
\begin{lstlisting}[language=python]
movie_colection = db["movies"]
pipeline = [
	{
		"$match": {
			"title": "A Star Is Born"
		}	
	},
	{
		"$sort": {
			"year": pymongo.ASCENDING
		}
	},
]
results = movie_colecction.aggregate(pipeline)
\end{lstlisting}
Si ahora quisieramos limitar la salida a un único documento\dots
\begin{lstlisting}[language=python]
movie_colection = db["movies"]
pipeline = [
	{
		"$match": {
			"title": "A Star Is Born"
		}	
	},
	{
		"$sort": {
			"year": pymongo.ASCENDING
		}
	},
	{"$limit": 1}
]
results = movie_colecction.aggregate(pipeline)
\end{lstlisting}

\Ej

Vamos a suponer ahora que existe otra colección llamada \texttt{comments} cuyos documentos tienen este formato
\begin{lstlisting}[language=python]
{
	'_id': ObjectId('5a9427648b0beebeb69579d3'),
	'movie_id': ObjectId('573a1390f2931caabcd4217'),
	'date': datetime.datetime(1983, 4, 27, 20, 39, 15),
	'email': 'cameron_duran@fakegmail.com',
	'name': 'Cameron Duran',
	'text': '...'}
\end{lstlisting}

Esto permitiría añadir un campo \code{related_comments} a cada película con sus críticas asociadas

\begin{lstlisting}[language=python]
stage_lookup_comments = {
	"$lookup": {
		"from": "comments",
		"localField": "_id",
		"foreignField": "movie_id",
		"as": "related_comments",	
	}
}
# Limitamos a los primeros 5 documentos
stage_limit_5 = {"$limit": 5}
pipeline = [stage_lookup_comments, stage_limit_5]
results = movie_collection.aggregate(pipeline)
\end{lstlisting}

\Ej

Una funcionalidad muy interesante es la agrupación de documentos con el comando \code{\$group}

Vamos a usar dicho comando para contar el número de películas por año, ordenadas de forma ascendente

\begin{lstlisting}[language=python]
stage_group_year = {
	"$group": {
		"_id": "$year",
		# contamos el número de películas en el grupo
		'movie_count': { "$sum": 1 },
	}
}
stage_match_years = {
	"$match": {
		"year": {
			"$type": "number",
		}
	}
}
stage_sort_year_ascending = {
	"$sort": {"_id": pymongo.ASCENDING}
}
pipeline = [stage_match_years, stage_group_year, stage_sort_year_ascending]
results = movie_colecction.aggregate(pipeline)
\end{lstlisting}
\subsubsection{Índices}
\subsubsubsection{Creación de índices}
En MongoDB, la creación de índices se realiza mediante el método \code{create_index}
\begin{lstlisting}[language=python]
db.collection.create_index([(<key and index type specification>)], <options> )
\end{lstlisting}
En el siguiente ejemplo se crea un índice con una sola clave (\texttt{nombre}) en orden descendente
\begin{lstlisting}[language=python]
collection.create_index([("nombre", pymongo.DESCENDING)])
\end{lstlisting}
Podemos listar los índices que tenemos creados en una colección con 
\begin{lstlisting}[language=python]
collection.index_information()
\end{lstlisting}
En el caso de las colecciones con alta proporción de escritura por lectura, los índices son caros porque cada inserción y actualización también debe actualizar cualquier índices.
\subsubsubsection{Nombrado y borrado de índices}
Al crear un índice, puede darle un nombre personalizado

Ayuda a distinguir los distintos índices de la colección.

Para especificar el nombre del índice, incluya la opción de nombre al crear el índice:
\begin{lstlisting}[language=python]
db.collection.create_index(
	{ "<campo>": "<valor>" },
	{ "name": "<NombreDelIndice>" }
)
\end{lstlisting}
Para borrar un índice podemos hacerlo con el método \code{.drop_index}
\begin{lstlisting}[language=python]
colecction.drop_index("<NombreDelIndice>")
\end{lstlisting}
\subsubsubsection{Tipos de índices en MongoDB}
\begin{itemize}[label=\color{red}\textbullet, leftmargin=*]
	\item \color{lightblue}Índices compuestos (\textit{compound indexes})
\end{itemize}
Los índices compuestos recopilan y ordenan datos de dos o más campos de cada documento de una colección.

Los datos se agrupan por el primer campo del índice y, a continuación, por cada campo subsiguiente.

Para su creación se sigue un formato parecido al de los \code{single field index}
\begin{lstlisting}[language=python]
db.<collection>.create_index( {
	<campo1>: <tipoDeOrdenacion>,
	<campo2>: <tipoDeOrdenacion>,
	...
	<campoN>: <tipoDeOrdenacion>
} )
\end{lstlisting}
Ejemplo: si quisieramos crear un índice sobre los campos \texttt{userid} (de forma ascendente) y \texttt{score} (de forma descendente) de los documentos de una colección \texttt{usuarios} deberíamos ejecutar
\begin{lstlisting}[language=python]
	db.usuarios.create_index({"userid": 1, "score": -1})
\end{lstlisting}
\begin{center}
	\includegraphics{"Temas/Tema 3/screenshot005"}
\end{center}
