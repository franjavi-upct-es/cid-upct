#| echo: false
from sympy import symbols, Or, And
from sympy.logic.boolalg import Equivalent
# Definición de las variables lógicas
p, q = symbols('p q')
# Construir la cabecera de la tabla en formato Markdown
tabla = "| p | q | p or q | p and q | p <-> q |\n"
tabla += "|---|---|--------|---------|---------|\n"
# Lista de combinaciones de valores para p y q
combinaciones = [(True, True), (True, False), (False, True), (False, False)]
# Evaluación y generación de cada fila en formato Markdown (con 1 y 0)
for p_val, q_val in combinaciones:
or_res    = int(bool(Or(p, q).subs({p: p_val, q: q_val})))
and_res   = int(bool(And(p, q).subs({p: p_val, q: q_val})))
equiv_res = int(bool(Equivalent(p, q).subs({p: p_val, q: q_val})))
tabla += "| {} | {} | {} | {} | {} |\n".format(int(p_val), int(q_val), or_res, and_res, equiv_res)
print(tabla)
#| echo: false
#| results: asis
from sympy import symbols, Or, And
from sympy.logic.boolalg import Equivalent
# Definición de las variables lógicas
p, q = symbols('p q')
# Construir la cabecera de la tabla en formato Markdown
tabla = "| p | q | p or q | p and q | p <-> q |\n"
tabla += "|---|---|--------|---------|---------|\n"
# Lista de combinaciones de valores para p y q
combinaciones = [(True, True), (True, False), (False, True), (False, False)]
# Evaluación y generación de cada fila en formato Markdown (con 1 y 0)
for p_val, q_val in combinaciones:
or_res    = int(bool(Or(p, q).subs({p: p_val, q: q_val})))
and_res   = int(bool(And(p, q).subs({p: p_val, q: q_val})))
equiv_res = int(bool(Equivalent(p, q).subs({p: p_val, q: q_val})))
tabla += "| {} | {} | {} | {} | {} |\n".format(int(p_val), int(q_val), or_res, and_res, equiv_res)
tabla
#| echo: false
#| results: asis
from sympy import symbols, Or, And
from sympy.logic.boolalg import Equivalent
# Definición de las variables lógicas
p, q = symbols('p q')
# Construir la cabecera de la tabla en formato Markdown
tabla = "| p | q | p or q | p and q | p <-> q |\n"
tabla += "|---|---|--------|---------|---------|\n"
# Lista de combinaciones de valores para p y q
combinaciones = [(True, True), (True, False), (False, True), (False, False)]
# Evaluación y generación de cada fila en formato Markdown (con 1 y 0)
for p_val, q_val in combinaciones:
or_res    = int(bool(Or(p, q).subs({p: p_val, q: q_val})))
and_res   = int(bool(And(p, q).subs({p: p_val, q: q_val})))
equiv_res = int(bool(Equivalent(p, q).subs({p: p_val, q: q_val})))
tabla += "| {} | {} | {} | {} | {} |\n".format(int(p_val), int(q_val), or_res, and_res, equiv_res)
print(tabla)
#| echo: false
#| results: asis
from sympy import symbols, Or, And
from sympy.logic.boolalg import Equivalent
from tabulate import tabulate
# Definición de las variables lógicas
p, q = symbols('p q')
# Encabezados de la tabla
headers = ["p", "q", "p or q", "p and q", "p <-> q"]
# Listado de combinaciones
combinaciones = [(True, True), (True, False), (False, True), (False, False)]
# Se construyen las filas evaluando cada combinación
filas = []
for p_val, q_val in combinaciones:
or_res    = int(bool(Or(p, q).subs({p: p_val, q: q_val})))
and_res   = int(bool(And(p, q).subs({p: p_val, q: q_val})))
equiv_res = int(bool(Equivalent(p, q).subs({p: p_val, q: q_val})))
filas.append([int(p_val), int(q_val), or_res, and_res, equiv_res])
# Imprime la tabla en formato Markdown usando tabulate con tablefmt="pipe"
print(tabulate(filas, headers=headers, tablefmt="pipe"))
#| echo: false
#| results: asis
from sympy import symbols, Or, And
from sympy.logic.boolalg import Equivalent
from tabulate import tabulate
from IPython.display import Markdown, display
# Definición de las variables lógicas
p, q = symbols('p q')
# Encabezados de la tabla
headers = [r"$p$", r"$q$", r"$p \lor q$", r"$p \land q$", r"$p \leftrightarrow q$"]
# Lista de combinaciones para p y q
combinaciones = [(True, True), (True, False), (False, True), (False, False)]
# Construir las filas evaluando cada combinación, con 1 para True y 0 para False
filas = []
for p_val, q_val in combinaciones:
or_res    = int(bool(Or(p, q).subs({p: p_val, q: q_val})))
and_res   = int(bool(And(p, q).subs({p: p_val, q: q_val})))
equiv_res = int(bool(Equivalent(p, q).subs({p: p_val, q: q_val})))
filas.append([int(p_val), int(q_val), or_res, and_res, equiv_res])
# Generar la tabla Markdown usando tabulate con el formato "pipe"
tabla = tabulate(filas, headers=headers)
# Mostrar la tabla como Markdown para que Quarto la renderice correctamente
display(Markdown(tabla))
